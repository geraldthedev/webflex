{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/workspace/webflex/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/workspace/webflex/node_modules/@babel/runtime/helpers/createClass\");\n\nvar retrieveBSON = require('../connection/utils').retrieveBSON;\n\nvar KillCursor = require('../connection/commands').KillCursor;\n\nvar GetMore = require('../connection/commands').GetMore;\n\nvar Query = require('../connection/commands').Query;\n\nvar MongoError = require('../error').MongoError;\n\nvar getReadPreference = require('./shared').getReadPreference;\n\nvar applyCommonQueryOptions = require('./shared').applyCommonQueryOptions;\n\nvar isMongos = require('./shared').isMongos;\n\nvar databaseNamespace = require('./shared').databaseNamespace;\n\nvar collectionNamespace = require('./shared').collectionNamespace;\n\nvar BSON = retrieveBSON();\nvar Long = BSON.Long;\n\nvar WireProtocol =\n/*#__PURE__*/\nfunction () {\n  function WireProtocol() {\n    _classCallCheck(this, WireProtocol);\n  }\n\n  _createClass(WireProtocol, [{\n    key: \"insert\",\n    value: function insert(server, ns, ops, options, callback) {\n      executeWrite(this, server, 'insert', 'documents', ns, ops, options, callback);\n    }\n  }, {\n    key: \"update\",\n    value: function update(server, ns, ops, options, callback) {\n      executeWrite(this, server, 'update', 'updates', ns, ops, options, callback);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(server, ns, ops, options, callback) {\n      executeWrite(this, server, 'delete', 'deletes', ns, ops, options, callback);\n    }\n  }, {\n    key: \"killCursor\",\n    value: function killCursor(server, ns, cursorState, callback) {\n      var bson = server.s.bson;\n      var pool = server.s.pool;\n      var cursorId = cursorState.cursorId;\n      var killCursor = new KillCursor(bson, ns, [cursorId]);\n      var options = {\n        immediateRelease: true,\n        noResponse: true\n      };\n\n      if (typeof cursorState.session === 'object') {\n        options.session = cursorState.session;\n      }\n\n      if (pool && pool.isConnected()) {\n        try {\n          pool.write(killCursor, options, callback);\n        } catch (err) {\n          if (typeof callback === 'function') {\n            callback(err, null);\n          } else {\n            console.warn(err);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getMore\",\n    value: function getMore(server, ns, cursorState, batchSize, options, callback) {\n      var bson = server.s.bson;\n      var getMore = new GetMore(bson, ns, cursorState.cursorId, {\n        numberToReturn: batchSize\n      });\n\n      function queryCallback(err, result) {\n        if (err) return callback(err);\n        var response = result.message; // If we have a timed out query or a cursor that was killed\n\n        if (response.cursorNotFound) {\n          return callback(new MongoError('Cursor does not exist, was killed, or timed out'), null);\n        }\n\n        var cursorId = typeof response.cursorId === 'number' ? Long.fromNumber(response.cursorId) : response.cursorId;\n        cursorState.documents = response.documents;\n        cursorState.cursorId = cursorId;\n        callback(null, null, response.connection);\n      }\n\n      var queryOptions = applyCommonQueryOptions({}, cursorState);\n      server.s.pool.write(getMore, queryOptions, queryCallback);\n    }\n  }, {\n    key: \"query\",\n    value: function query(server, ns, cmd, cursorState, options, callback) {\n      if (cursorState.cursorId != null) {\n        return;\n      }\n\n      var query = setupClassicFind(server, ns, cmd, cursorState, options);\n      var queryOptions = applyCommonQueryOptions({}, cursorState);\n\n      if (typeof query.documentsReturnedIn === 'string') {\n        queryOptions.documentsReturnedIn = query.documentsReturnedIn;\n      }\n\n      server.s.pool.write(query, queryOptions, callback);\n    }\n  }, {\n    key: \"command\",\n    value: function command(server, ns, cmd, options, callback) {\n      if (cmd == null) {\n        return callback(new MongoError(\"command \".concat(JSON.stringify(cmd), \" does not return a cursor\")));\n      }\n\n      options = options || {};\n      var bson = server.s.bson;\n      var pool = server.s.pool;\n      var readPreference = getReadPreference(cmd, options);\n      var finalCmd = Object.assign({}, cmd);\n\n      if (finalCmd.readConcern) {\n        if (finalCmd.readConcern.level !== 'local') {\n          return callback(new MongoError(\"server \".concat(JSON.stringify(finalCmd), \" command does not support a readConcern level of \").concat(finalCmd.readConcern.level)));\n        }\n\n        delete finalCmd['readConcern'];\n      }\n\n      if (isMongos(server) && readPreference && readPreference.preference !== 'primary') {\n        finalCmd = {\n          $query: finalCmd,\n          $readPreference: readPreference.toJSON()\n        };\n      }\n\n      var commandOptions = Object.assign({\n        command: true,\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false\n      }, options); // This value is not overridable\n\n      commandOptions.slaveOk = readPreference.slaveOk();\n\n      try {\n        var query = new Query(bson, \"\".concat(databaseNamespace(ns), \".$cmd\"), finalCmd, commandOptions);\n        pool.write(query, commandOptions, callback);\n      } catch (err) {\n        callback(err);\n      }\n    }\n  }]);\n\n  return WireProtocol;\n}();\n\nfunction executeWrite(handler, server, type, opsField, ns, ops, options, callback) {\n  if (ops.length === 0) throw new MongoError('insert must contain at least one document');\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n    options = options || {};\n  }\n\n  var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  var writeConcern = options.writeConcern;\n  var writeCommand = {};\n  writeCommand[type] = collectionNamespace(ns);\n  writeCommand[opsField] = ops;\n  writeCommand.ordered = ordered;\n\n  if (writeConcern && Object.keys(writeConcern).length > 0) {\n    writeCommand.writeConcern = writeConcern;\n  }\n\n  if (options.bypassDocumentValidation === true) {\n    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;\n  }\n\n  var commandOptions = Object.assign({\n    checkKeys: type === 'insert',\n    numberToReturn: 1\n  }, options);\n  handler.command(server, ns, writeCommand, commandOptions, callback);\n}\n\nfunction setupClassicFind(server, ns, cmd, cursorState, options) {\n  options = options || {};\n  var bson = server.s.bson;\n  var readPreference = getReadPreference(cmd, options);\n  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;\n  var numberToReturn = 0;\n\n  if (cursorState.limit === 0) {\n    numberToReturn = cursorState.batchSize;\n  } else if (cursorState.limit < 0 || cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize === 0) {\n    numberToReturn = cursorState.limit;\n  } else {\n    numberToReturn = cursorState.batchSize;\n  }\n\n  var numberToSkip = cursorState.skip || 0;\n  var findCmd = {};\n\n  if (isMongos(server) && readPreference) {\n    findCmd['$readPreference'] = readPreference.toJSON();\n  }\n\n  if (cmd.sort) findCmd['$orderby'] = cmd.sort;\n  if (cmd.hint) findCmd['$hint'] = cmd.hint;\n  if (cmd.snapshot) findCmd['$snapshot'] = cmd.snapshot;\n  if (typeof cmd.returnKey !== 'undefined') findCmd['$returnKey'] = cmd.returnKey;\n  if (cmd.maxScan) findCmd['$maxScan'] = cmd.maxScan;\n  if (cmd.min) findCmd['$min'] = cmd.min;\n  if (cmd.max) findCmd['$max'] = cmd.max;\n  if (typeof cmd.showDiskLoc !== 'undefined') findCmd['$showDiskLoc'] = cmd.showDiskLoc;\n  if (cmd.comment) findCmd['$comment'] = cmd.comment;\n  if (cmd.maxTimeMS) findCmd['$maxTimeMS'] = cmd.maxTimeMS;\n\n  if (cmd.explain) {\n    // nToReturn must be 0 (match all) or negative (match N and close cursor)\n    // nToReturn > 0 will give explain results equivalent to limit(0)\n    numberToReturn = -Math.abs(cmd.limit || 0);\n    findCmd['$explain'] = true;\n  }\n\n  findCmd['$query'] = cmd.query;\n\n  if (cmd.readConcern && cmd.readConcern.level !== 'local') {\n    throw new MongoError(\"server find command does not support a readConcern level of \".concat(cmd.readConcern.level));\n  }\n\n  if (cmd.readConcern) {\n    cmd = Object.assign({}, cmd);\n    delete cmd['readConcern'];\n  }\n\n  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;\n  var query = new Query(bson, ns, findCmd, {\n    numberToSkip: numberToSkip,\n    numberToReturn: numberToReturn,\n    pre32Limit: typeof cmd.limit !== 'undefined' ? cmd.limit : undefined,\n    checkKeys: false,\n    returnFieldSelector: cmd.fields,\n    serializeFunctions: serializeFunctions,\n    ignoreUndefined: ignoreUndefined\n  });\n  if (typeof cmd.tailable === 'boolean') query.tailable = cmd.tailable;\n  if (typeof cmd.oplogReplay === 'boolean') query.oplogReplay = cmd.oplogReplay;\n  if (typeof cmd.noCursorTimeout === 'boolean') query.noCursorTimeout = cmd.noCursorTimeout;\n  if (typeof cmd.awaitData === 'boolean') query.awaitData = cmd.awaitData;\n  if (typeof cmd.partial === 'boolean') query.partial = cmd.partial;\n  query.slaveOk = readPreference.slaveOk();\n  return query;\n}\n\nmodule.exports = WireProtocol;","map":null,"metadata":{},"sourceType":"script"}
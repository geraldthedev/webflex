{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/workspace/webflex/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/workspace/webflex/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Query = require('../connection/commands').Query;\n\nvar retrieveBSON = require('../connection/utils').retrieveBSON;\n\nvar MongoError = require('../error').MongoError;\n\nvar MongoNetworkError = require('../error').MongoNetworkError;\n\nvar getReadPreference = require('./shared').getReadPreference;\n\nvar BSON = retrieveBSON();\nvar Long = BSON.Long;\n\nvar ReadPreference = require('../topologies/read_preference');\n\nvar TxnState = require('../transactions').TxnState;\n\nvar isMongos = require('./shared').isMongos;\n\nvar databaseNamespace = require('./shared').databaseNamespace;\n\nvar collectionNamespace = require('./shared').collectionNamespace;\n\nvar WireProtocol =\n/*#__PURE__*/\nfunction () {\n  function WireProtocol() {\n    _classCallCheck(this, WireProtocol);\n  }\n\n  _createClass(WireProtocol, [{\n    key: \"insert\",\n    value: function insert(server, ns, ops, options, callback) {\n      executeWrite(this, server, 'insert', 'documents', ns, ops, options, callback);\n    }\n  }, {\n    key: \"update\",\n    value: function update(server, ns, ops, options, callback) {\n      executeWrite(this, server, 'update', 'updates', ns, ops, options, callback);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(server, ns, ops, options, callback) {\n      executeWrite(this, server, 'delete', 'deletes', ns, ops, options, callback);\n    }\n  }, {\n    key: \"killCursor\",\n    value: function killCursor(server, ns, cursorState, callback) {\n      callback = typeof callback === 'function' ? callback : function () {};\n      var cursorId = cursorState.cursorId;\n      var killCursorCmd = {\n        killCursors: collectionNamespace(ns),\n        cursors: [cursorId]\n      };\n      var options = {};\n      if (typeof cursorState.session === 'object') options.session = cursorState.session;\n      this.command(server, ns, killCursorCmd, options, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        var response = result.message;\n\n        if (response.cursorNotFound) {\n          return callback(new MongoNetworkError('cursor killed or timed out'), null);\n        }\n\n        if (!Array.isArray(response.documents) || response.documents.length === 0) {\n          return callback(new MongoError(\"invalid killCursors result returned for cursor id \".concat(cursorId)));\n        }\n\n        callback(null, response.documents[0]);\n      });\n    }\n  }, {\n    key: \"getMore\",\n    value: function getMore(server, ns, cursorState, batchSize, options, callback) {\n      options = options || {};\n      var getMoreCmd = {\n        getMore: cursorState.cursorId,\n        collection: collectionNamespace(ns),\n        batchSize: Math.abs(batchSize)\n      };\n\n      if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === 'number') {\n        getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;\n      }\n\n      function queryCallback(err, result) {\n        if (err) return callback(err);\n        var response = result.message; // If we have a timed out query or a cursor that was killed\n\n        if (response.cursorNotFound) {\n          return callback(new MongoNetworkError('cursor killed or timed out'), null);\n        } // Raw, return all the extracted documents\n\n\n        if (cursorState.raw) {\n          cursorState.documents = response.documents;\n          cursorState.cursorId = response.cursorId;\n          return callback(null, response.documents);\n        } // We have an error detected\n\n\n        if (response.documents[0].ok === 0) {\n          return callback(new MongoError(response.documents[0]));\n        } // Ensure we have a Long valid cursor id\n\n\n        var cursorId = typeof response.documents[0].cursor.id === 'number' ? Long.fromNumber(response.documents[0].cursor.id) : response.documents[0].cursor.id;\n        cursorState.documents = response.documents[0].cursor.nextBatch;\n        cursorState.cursorId = cursorId;\n        callback(null, response.documents[0], response.connection);\n      }\n\n      var commandOptions = Object.assign({\n        returnFieldSelector: null,\n        documentsReturnedIn: 'nextBatch'\n      }, options);\n      this.command(server, ns, getMoreCmd, commandOptions, queryCallback);\n    }\n  }, {\n    key: \"query\",\n    value: function query(server, ns, cmd, cursorState, options, callback) {\n      options = options || {};\n\n      if (cursorState.cursorId != null) {\n        return callback();\n      }\n\n      if (cmd == null) {\n        return callback(new MongoError(\"command \".concat(JSON.stringify(cmd), \" does not return a cursor\")));\n      }\n\n      var readPreference = getReadPreference(cmd, options);\n      var findCmd = prepareFindCommand(server, ns, cmd, cursorState, options); // NOTE: This actually modifies the passed in cmd, and our code _depends_ on this\n      //       side-effect. Change this ASAP\n\n      cmd.virtual = false;\n      var commandOptions = Object.assign({\n        documentsReturnedIn: 'firstBatch',\n        numberToReturn: 1,\n        slaveOk: readPreference.slaveOk()\n      }, options);\n      if (cmd.readPreference) commandOptions.readPreference = readPreference;\n      this.command(server, ns, findCmd, commandOptions, callback);\n    }\n  }, {\n    key: \"command\",\n    value: function command(server, ns, cmd, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options || {};\n\n      if (cmd == null) {\n        return callback(new MongoError(\"command \".concat(JSON.stringify(cmd), \" does not return a cursor\")));\n      }\n\n      var bson = server.s.bson;\n      var pool = server.s.pool;\n      var readPreference = getReadPreference(cmd, options);\n      var finalCmd = Object.assign({}, cmd);\n\n      if (isMongos(server) && readPreference && readPreference.preference !== 'primary') {\n        finalCmd = {\n          $query: finalCmd,\n          $readPreference: readPreference.toJSON()\n        };\n      }\n\n      var err = decorateWithSessionsData(finalCmd, options.session, options);\n\n      if (err) {\n        return callback(err);\n      }\n\n      var commandOptions = Object.assign({\n        command: true,\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false\n      }, options); // This value is not overridable\n\n      commandOptions.slaveOk = readPreference.slaveOk();\n\n      try {\n        var query = new Query(bson, \"\".concat(databaseNamespace(ns), \".$cmd\"), finalCmd, commandOptions);\n        pool.write(query, commandOptions, callback);\n      } catch (err) {\n        callback(err);\n      }\n    }\n  }]);\n\n  return WireProtocol;\n}();\n\nfunction isTransactionCommand(command) {\n  return !!(command.commitTransaction || command.abortTransaction);\n}\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param {Object} command the command to decorate\n * @param {ClientSession} session the session tracking transaction state\n * @param {Object} [options] Optional settings passed to calling operation\n * @param {Function} [callback] Optional callback passed from calling operation\n * @return {MongoError|null} An error, if some error condition was met\n */\n\n\nfunction decorateWithSessionsData(command, session, options) {\n  if (!session) {\n    return;\n  } // first apply non-transaction-specific sessions data\n\n\n  var serverSession = session.serverSession;\n  var inTransaction = session.inTransaction() || isTransactionCommand(command);\n  var isRetryableWrite = options.willRetryWrite;\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = BSON.Long.fromNumber(serverSession.txnNumber);\n  } // now attempt to apply transaction-specific sessions data\n\n\n  if (!inTransaction) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    } // for causal consistency\n\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n\n    return;\n  }\n\n  if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {\n    return new MongoError(\"Read preference in a transaction must be primary, not: \".concat(options.readPreference.mode));\n  } // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    var readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n}\n\nfunction executeWrite(handler, server, type, opsField, ns, ops, options, callback) {\n  if (ops.length === 0) throw new MongoError('insert must contain at least one document');\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n    options = options || {};\n  }\n\n  var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  var writeConcern = options.writeConcern;\n  var writeCommand = {};\n  writeCommand[type] = collectionNamespace(ns);\n  writeCommand[opsField] = ops;\n  writeCommand.ordered = ordered;\n\n  if (writeConcern && Object.keys(writeConcern).length > 0) {\n    writeCommand.writeConcern = writeConcern;\n  }\n\n  if (options.collation) {\n    for (var i = 0; i < writeCommand[opsField].length; i++) {\n      if (!writeCommand[opsField][i].collation) {\n        writeCommand[opsField][i].collation = options.collation;\n      }\n    }\n  }\n\n  if (options.bypassDocumentValidation === true) {\n    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;\n  }\n\n  var commandOptions = Object.assign({\n    checkKeys: type === 'insert',\n    numberToReturn: 1\n  }, options);\n  handler.command(server, ns, writeCommand, commandOptions, callback);\n}\n\nfunction prepareFindCommand(server, ns, cmd, cursorState) {\n  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;\n  var findCmd = {\n    find: collectionNamespace(ns)\n  };\n\n  if (cmd.query) {\n    if (cmd.query['$query']) {\n      findCmd.filter = cmd.query['$query'];\n    } else {\n      findCmd.filter = cmd.query;\n    }\n  }\n\n  var sortValue = cmd.sort;\n\n  if (Array.isArray(sortValue)) {\n    var sortObject = {};\n\n    if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {\n      var sortDirection = sortValue[1];\n\n      if (sortDirection === 'asc') {\n        sortDirection = 1;\n      } else if (sortDirection === 'desc') {\n        sortDirection = -1;\n      }\n\n      sortObject[sortValue[0]] = sortDirection;\n    } else {\n      for (var i = 0; i < sortValue.length; i++) {\n        var _sortDirection = sortValue[i][1];\n\n        if (_sortDirection === 'asc') {\n          _sortDirection = 1;\n        } else if (_sortDirection === 'desc') {\n          _sortDirection = -1;\n        }\n\n        sortObject[sortValue[i][0]] = _sortDirection;\n      }\n    }\n\n    sortValue = sortObject;\n  }\n\n  if (cmd.sort) findCmd.sort = sortValue;\n  if (cmd.fields) findCmd.projection = cmd.fields;\n  if (cmd.hint) findCmd.hint = cmd.hint;\n  if (cmd.skip) findCmd.skip = cmd.skip;\n  if (cmd.limit) findCmd.limit = cmd.limit;\n\n  if (cmd.limit < 0) {\n    findCmd.limit = Math.abs(cmd.limit);\n    findCmd.singleBatch = true;\n  }\n\n  if (typeof cmd.batchSize === 'number') {\n    if (cmd.batchSize < 0) {\n      if (cmd.limit !== 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {\n        findCmd.limit = Math.abs(cmd.batchSize);\n      }\n\n      findCmd.singleBatch = true;\n    }\n\n    findCmd.batchSize = Math.abs(cmd.batchSize);\n  }\n\n  if (cmd.comment) findCmd.comment = cmd.comment;\n  if (cmd.maxScan) findCmd.maxScan = cmd.maxScan;\n  if (cmd.maxTimeMS) findCmd.maxTimeMS = cmd.maxTimeMS;\n  if (cmd.min) findCmd.min = cmd.min;\n  if (cmd.max) findCmd.max = cmd.max;\n  findCmd.returnKey = cmd.returnKey ? cmd.returnKey : false;\n  findCmd.showRecordId = cmd.showDiskLoc ? cmd.showDiskLoc : false;\n  if (cmd.snapshot) findCmd.snapshot = cmd.snapshot;\n  if (cmd.tailable) findCmd.tailable = cmd.tailable;\n  if (cmd.oplogReplay) findCmd.oplogReplay = cmd.oplogReplay;\n  if (cmd.noCursorTimeout) findCmd.noCursorTimeout = cmd.noCursorTimeout;\n  if (cmd.awaitData) findCmd.awaitData = cmd.awaitData;\n  if (cmd.awaitdata) findCmd.awaitData = cmd.awaitdata;\n  if (cmd.partial) findCmd.partial = cmd.partial;\n  if (cmd.collation) findCmd.collation = cmd.collation;\n  if (cmd.readConcern) findCmd.readConcern = cmd.readConcern; // If we have explain, we need to rewrite the find command\n  // to wrap it in the explain command\n\n  if (cmd.explain) {\n    findCmd = {\n      explain: findCmd\n    };\n  }\n\n  return findCmd;\n}\n\nmodule.exports = WireProtocol;","map":null,"metadata":{},"sourceType":"script"}